### 1.1.1 제어 역전(IoC)
: 객체의 관리를 컨테이너에 맡겨 제어권이 넘어간 것을 제어 역전이라고 부르며, 제어 역전을 통해 의존성 주입(Dependency Injection), 관점 지향 프로그래밍(AOP: Aspect-Oriented Programming) 등이 가능해진다. 스프링을 사용하면 객체의 제어권을 컨테이너로 넘기기 때문에 개발자는 비즈니스 로직을 작성하는데 집중할 수 있음. 

### 1.1.2 의존성 주입(DI)
: 제어 역전의 방법 중 하나로, 사용할 객체를 직접 생성하지 않고 외부 컨테이너가 생성한 객체를 주입받아 사용하는 방식을 의미한다. 

스프링에서 의존성을 주입받는 방식은 
1. 생성자를 통한 의존성 주입
2. 필드 객체 선언을 통한 의존성 주입
3. 세터 메서드를 통한 의존성 주입 

### 1.1.3 관점지향프로그래밍(AOP:Aspect-Oriented Programming)

AOP는 관점을 기준으로 묶어 개발하는 방식, 여기서의 관점은 핵심과 부가 기능으로 구분해 각각을 하나의 관점으로 보는 것을 의미
핵심 기능은 비즈니스 로직을 구현하는 과정에서 비즈니스 로직이 처리하려는 목적 기능을 말함. 예를 들면 클라이언트로부터 상품 정보 등록 요청을 받아 데이터베이스에 저장하고, 그 상품 정보를 조회하는 비즈니스 로직을 구현한다면 (1) 상품 정보를 데이터베이스에 저장하고, (2) 저장된 상품 정보 데이터를 보여주는 코드가 핵심 기능

실제 어플리케이션 개발할때 핵심 기능에 부가 기능을 추가할 상황이 생기는데, 예를 들면 핵심 기능인 비즈니스 로직 사이에 로깅 처리를 하거나, 트랙잭션을 처리하는 코드를 예로 들 수 있다. 

### 1.1.4 스프링 프레임워크의 다양한 모듈
기능별로 구분된 약 20여 개의 모듈로 구성되어 있음. 
spring-overview.png 
스프링 프레임워크를 사용한다고 해서 모든 모듈을 사용할 필요는 없음 .

## 1.2 스프링 프레임워크 VS 스프링 부트
필요한 모듈들을 추가하다보면 설정이 복잡해지는 문제를 해결하기 위해 등장한 것이 스프링부트이다. 

### 1.2.1 의존성 관리 
스프링 프레임워크에서는 개발에 필요한 각 모듈의 의존성을 직접 설정해야 했는데, spring-boot-starter라는 라이브러리 의존성을 제공한다. 
ex) 
spring-boot-starter-web: 스프링 MVC를 사용하는 RESTful 애플리케이션을 만들기 위한 의존성, 기본으로 내장 톰캣이 포함돼 있어 jar 형식으로 실행 가능함. 
spring-boot-starter-test: JUnit Jupiter, Mockito 등의 테스트용 라이브러러를 포함 
spring-boot-starter-jdbc: HikariCP 커넥션 풀을 활용한 JDBC 기능을 제공
spring-boot-starter-security: 스프링 시큐리티(인증, 권한, 인가 등) 기능을 제공
spring-boot-starter-data-jpa: 하이버네이트를 활용한 JPA 기능을 제공
spring-boot-starter-cache: 스프링 프레임워크의 캐시 기능 지원 
--> 여러 라이브러리를 함께 사용할 때 의존성 겹칠 수 있음, 이를 해결하기 위해 spring-boot-starter-parent가 검증된 조합을 제공함. 

### 1.2.2 자동 설정 
스프링 부트는 스프링 프레임워크의 기능을 사용하기 위한 자동 설정(Auto Configuration)을 지원함. 
@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan

스프링 부트 애플리케이션이 실행되면 
우선 @ComponentScan 애너테이션이 @Component 시리즈 애너테이션이 붙은 클래스를 발견해 빈(bean)을 등록함. 
이후 @EnableAutoConfiguration 애너테이션을 통해 AutoConfigurationImportSelector 클래스가 동작하게 하며, 
이 클래스는 AutoConfiguration.imports 파일의 설정 정보를 읽어 일부 조건을 거쳐 스프링 컨테이너에 등록해서 사용할 수 있게 도와준다. 

@Component 시리즈 애너테이션에서 시리즈는 @Component 애너테이션이 포괄하는 애너테이션들을 통칭하기 위해 사용한 표현 
-> @Controller, @RestController, @Service, @Repository, @Configuration 

### 1.2.3. 내장 WAS
스프링 부트 각 웹 어플리케이션에는 내장 WAS(Web-Application-Server)가 존재함. 
spring-boot-starter-web이 톰캣을 내장한다. 

### 1.2.4 모니터링
스레드, 메모리, 세션 등의 주요 요소를 모니터링하는 도구 
Spring Boot Actuator 라는 자체 모니터링 도구가 있음. 

### 2.1 서버 간 통신 
마이크로서비스 아키텍처(MSA)는 단어 그대로 서비스 규모를 작게 나누어 구성한 아키텍처를 뜻한다. 

### 2.2 스프링 부트의 동작 방식
스프링 부트의 동작 구조.png 
서블릿(Servlet)은 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술. 서블릿은 서블릿 컨테이너(Servlet Container)에서 관리한다. 서블릿 컨테이너는 서블릿 인스턴스를 생성하고 관리하는 역할을 수행하는 주체로서 톰캣은 WAS의 역할과 서블릿 컨테이너의 역할을 수행하는 대표적인 컨테이너입니다. 
서블릿 컨테이너의 특징은 
1. 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리합니다. 
2. 서블릿 객체는 싱글턴 패턴으로 관리된다.
3. 멀티 스레딩을 지원한다. 

스프링에서는 DispatcherServlet이 서블릿 역할을 수행한다. 스프링은 톰캣을 임베드해 사용한다. 따라서 서블릿 컨테이너와 DispatcherServlet은 자동 설정된 web.xml의 설정값을 공유한다. 

스프링 구조의 동작구조를 보면 DispatcherServlet의 동작 
(1) DispatcherServlet으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet은 핸들러 매핑(HandlerMapping)을 통해 요청 URI에 매핑된 핸들러를 탐색한다. 
여기서 핸들러는 컨트롤러를 의미함. 
(2) 핸들러 어탭터로 컨트롤러를 호출한다. 
(3) 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndView로 응답을 가공해 반환한다. 
(4) 뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버를 통해 뷰를 받아 리턴한다. 

핸들러 매핑은 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스입니다. 핸들러 매핑 인터페이스는 여러 구현체를 가지며, 대표적인 구현체 클래스는 
BeanNameUrlHandlerMapping
: 빈 이름을 URL로 사용하는 매핑 전략, 빈을 정의할 때 슬래시가 들어가면 매핑 대상이 됨. ex) @Bean("/hello")
ControllerClassNameHandlerMapping 
: URL과 일치하는 클래스 이름을 갖는 빈을 컨트롤러로 사용하는 전략, 이름 중 Controller를 제외하고 앞부분에 작성된 suffix를 소문자로 매핑함
SimpleUrlHandlerMapping 
: URL 패턴에 매핑된 컨트롤러를 사용하는 전략
DefaultAnnotationHandlerMapping
: 애너테이션으로 URL과 컨트롤러를 매핑하는 방법 

### 2.3 레이어드 아키텍처 
레이어드 아키텍처(Layered Architecture)란 애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조를 의미함. 레이어드 아키텍처라 하면 보통 3계층, 4계층 구성을 의미한다. 
이 차이는 인프라(데이터베이스) 레이어의 추가 여부로 결정 

3계층 레이어드 아키텍처는 
1. 프레젠테이션 계층
애플리케이션의 최상단 계층으로, 클라이언트의 요청을 해석하고 응답하는 역할, UI나 API 제공하며, 별도의 비즈니스 로직을 포함하고 있지 않으므로 비즈니스 계층으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행
2. 비즈니스 계층
애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할을 수행한다. DDD(Domain-Driven Design) 기반의 아키텍처에서는 비즈니스 로직이 도메인에 포함되기도 하고, 별도로 도메인 계층을 두기도 함. 
3. 데이터 접근 계층 
데이터베이스에 접근하는 일련의 작업을 수행한다. 

스프링의 레이어드 아키텍처 
Spring MVC는 Model-View-Controller의 구조로 View와 Controller는 프레젠테이션 계층 영역이며, Model은 비즈니스와 데이터 접근 계층의 영역으로 구분할 수 있음. 다만 스프링 MVC 모델로 레이어드 아키텍처를 구현하기 위해서는 역할을 세분화함. 비즈니스 계층에 서비스를 배치해 엔티티와 같은 도메인 객체의 비즈니스 로직을 조합하도록 하고 데이터 접근 계층에는 DAO(Spring Data JPA에서는 Repository)를 배치해 도메인을 관리한다. 

1. 프레젠테이션 계층
상황에 따라 유저 인터페이스(UI) 계층이라고함. 클라이언트와의 접점이 되고, 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할을 함. 
2. 비즈니스 계층
상황에 따라 서비스 계층이라고 함. 핵심 비즈니스 로직을 구현하는 영역, 트랜잭션 처리나 유효성 검사 등의 작업도 수행 
3. 데이터 접근 계층
상황에 따라 영속 계층이라고 함. 데이터베이스에 접근해야 하는 작업을 수행한다. 

스프링에서는 JPA를 사용하면 @Entity를 정의한 클래스가 도메인 객체가 되며, 이곳에서 비즈니스 로직을 설계하면 좋음. 다만, 서비스 레이어에서 비즈니스 로직을 담당하는 경우도 있으므로 역할과 책을 잘 구분해서 설계해야 한다. 

### 2.4 디자인 패턴

#### 생성(Creation)패턴 (객체 생성에 사용되는 패턴으로 객체를 수정해도 호출부가 영향을 받지 않게 함.)
추상 팩토리 : 구체적인 클래스를 지정하지 않고 상황에 맞는 객체를 생성하기 위한 인터페이스를 제공하는 패턴
빌더 : 객체의 생성과 표현을 분리해 객체를 생성하는 패턴
팩토리 메서드 : 객체 생성을 서브클래스로 분리해서 위임하는 패턴
프로토타입 : 원본 객체를 복사해 객체를 생성하는 패턴
싱글턴 : 한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하나임을 보장하고 어느 곳에서도 접근할 수 있게 제공하는 패턴 

#### 구조(Structural) 패턴 (객체를 조합해서 더 큰 구조를 만드는 패턴)
어댑터 : 클래스의 인터페이스르르 의도하는 인터페이스로 변환하는 패턴
브리지 : 추상화와 구현을 분리해서 각각 독립적으로 변형하게 하는 패턴
컴포지트 : 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴
데코레이터 : 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 하는 패턴
파사드 : 서브시스템의 인터페이스 집합들에 하나의 통합된 인터페이스를 제공하는 패턴
플라이웨이트 : 특정 클래스의 인스턴스 한 개를 가지고 여러 개의 가상 인스턴스를 제공할 때 사용하는 패턴
프록시 : 특정 객체를 직접 참조하지 않고 해당 객체를 대행(프록시)하는 객체를 통해 접근하는 패턴

#### 행위(Behavoiral) 패턴 (객체 간의 알고리즘이나 책임 분배에 관한 패턴, 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배한다. 결합도 최소화를 고려할 필요 없음 )
책임 연쇄 : 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴
커맨드 : 실행될 기능을 캡슐화해서 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴
인터프리터 : 주어진 언어의 문법을 위한 표현 수단을 정의하고 해당 언어로 구성된 문장을 해석하는 패턴
이터레이터 : 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적으로 접근하는 방법을 제공하는 패턴
미디에이터 : 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴
메멘토 : 객체의 상태 정보를 저장하고 필요에 따라 상태를 복원하는 패턴
옵저버 : 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 패턴
스테이트 : 상태에 따라 객체가 행동을 변경하게 하는 패턴
스트레티지 : 행동을 클래스로 캡슐화해서 동적으로 행동을 바꿀 수 있게 하는 패턴
템플릿 메서드 : 일정 작업을 처리하는 부분을 서브클래스로 캡슐화해서 전체 수행 구조는 바꾸지 않으면서 특정 단계만 변경해서 수행하는 패턴
비지터 : 실제 로직을 가지고 있는 객체(Visitor)가 로직을 적용할 객체(element)를 방문하며 실행하는 패턴 

### 2.5 REST API
대중적으로 가장 많이 사용되는 어플리케이션 인터페이스

### 2.5.1 REST란? 
Representational State Transfer의 약자로 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템 아키텍처의 한 형식 
주고 받는 자원(Resource)에 이름을 규정하고 URI에 명시해 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것을 의미 

### 2.5.2 REST API란?
REST 아키텍처를 따르는 시스템/애플리케이션 인터페이스라고 볼 수 있음. REST 아키텍처를 구현하는 웹 서비스를 'RESTful하다'라고 표현함. 

### 2.5.3 REST 특징 
1. 유니폼 인터페이스 
유니폼 인터페이스란 일관된 인터페이스를 의미함. REST 서버는 HTTP 표준 전송 규약을 따르기 때문에 어떤 프로그래밍 언어로 만들어졌느냐와 상관없이 플랫폼 및 기술에 종속되지 않고 타 언어, 플랫폼, 기술 등과 호환해 사용할 수 있다는 것을 의미

2. 무상태성 
REST는 무상태성(Stateless)이라는 특징을 가짐. 무상태성이란 서버에 상태 정보를 따로 보관하거나 관리하지 않는다는 의미이다. 서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도 보관하지 않음. 
그렇기 때문에 한 클라이언트가 여러 요청을 보내든 여러 클라이언트가 각각 하나의 요청을 보내든 개별적으로 처리한다. 이렇게 구성된 서비스는 서버가 불필요한 정보를 관리하지 않으므로 비즈니스 로직의 자유도가 높고 설계가 단순하다. 

3. 캐시 가능성
REST는 HTTP 표준을 그대로 사용하므로 HTTP의 캐싱 기능을 적용할 수 있음. 이 기능을 사용하기 위해서는 응답과 요청이 모두 캐싱 가능(Cacheable)한지 명시가 필요하며, 캐싱이 가능한 경우 클라이언트에서 캐시에 저장해두고 같은 요청에 대해서는 해당 데이터를 가져다 사용합니다. 이 기능을 사용하면 서버의 트랜잭션 부하가 줄어 효율적이며 사용자 입장에서 성능이 개선된다. 

4. 레이어 시스템 
REST 서버는 네트워크 상의 여러 계층으로 구성될 수 있음. 그러나 서버의 복잡도와 관계없이 클라이언트는 서버와 연결되는 포인트만 알면 됨 

5. 클라이언트-서버 아키텍처 
REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계합니다. 이 구성은 서로에 대한 의존성을 낮추는 기능을 함

### 2.5.4 REST의 URI 설계 규칙 
URL 규칙 
1. URI의 마지막에는 '/'를 포함하지 않습니다.
2. 언더바(_)는 사용하지 않고, 하이픈(-)을 이용
3. URL에는 행위(동사)가 아닌 결과(명사)를 포함함
4. URI는 소문자로 작성해야 하. 
5. 파일의 확장자는 URI에 포함하지 않는다. 

pom.xml(Project Object Model) 메이븐의 기능을 사용하기 위해 작성하는 파일 

Talend API Tester를 통한 동작 테스트 (Swagger, Postman, APIdog 유사)

### 5.2 GET API 만들기 
웹 애플리케이션 서버에서 값을 가져올 때 사용하는 API이다. 

@RestController
@RequestMapping("/api/v1/get-api")
public class GetController {
}
클래스 수준에서 @RequestMapping을 설정하면 내부에 선언한 메서드의 URL 리소스 앞에 @RequestMapping 값이 공통 값으로 추가된다. 

@RequestMapping 애너테이션을 별다른 설정없이 선언하면 HTTP의 모든 요청을 받습니다. GET 형식의 요청만 받기 위해서는 애너테이션에 별도 설정이 필요함. 

### 5.2.4 @RequestParam을 활용한 GET 메서드 구현
GET 요청을 구현할 때 앞에서 살펴본 방법처럼 URL 경로에 값을 담아 요청을 보내는 방법 외에도 쿼리 형식으로 값을 전달할 수 도 있음. 
즉, URI에서 '?'를 기준으로 우측에 '{키}={값}' 형태로 구성된 요청을 전송하는 방법 

### 5.2.5 DTO 객체를 활용한 GET 메서드 구현 
DTO란? Data Transfer Object의 약자로 다른 레이어 간의 데이터 교환에 활용된다. DTO에는 별도의 로직이 포함되지 않음. 

VO는 데이터 그 자체로 의미가 있는 객체를 의미한다. VO의 가장 특징적인 부분은 Read-Only로 설계되었다. 
DTO는 데이터 전송을 위해 사용되는 데이터 컨테이너로 볼 수 있음. 같은 애플리케이션 내부에서 사용되는 것이 아니라 다른 서버(시스템)로 전달하는 경우에 사용된다. 

DTO 클래스에는 전달하고자 하는 필드 객체를 선언하고 게터/세터 메서드를 구현한다. DTO 클래스에 선언된 필드는 컨트롤러의 메서드에서 쿼리 파라미터의 키와 매핑된다. 쿼리 스트링의 키가 정해져 있지만 받아야 할 파라미터가 많을 경우에는 DTO 객체를 활용해 코드 가독성을 높일 수 있음. 


### 6.2 ORM
ORM이란 Object Relational Mapping의 줄임말로 객체 관계 매핑을 의미한다. 자바와 같은 객체지향 언어에서 의미하는 객체와 RDB의 테이블을 자동으로 매핑하는 방법

ORM의 장점
1. ORM을 사용하면서 데이터베이스의 쿼리를 객체지향적으로 조작할 수 있음.
- 쿼리문을 작성하는 양이 현저히 줄어 개발 비용이 줄어든다. 
- 객체지향적으로 데이터베이스에 접근할 수 있어 코드의 가독성을 높임
2. 재사용 및 유지보수가 편리함
- ORM을 통해 매핑된 객체는 모두 독립적으로 작성되어 있어 재사용이 용이함
- 객체들은 각 클래스로 나뉘어 있어 유지보수가 수월함.
3. 데이터베이스에 대한 종속성이 줄어듦
- ORM을 통해 자동 생성된 SQL문은 객체를 기반으로 데이터베이스 테이블을 관리하기 때문에 데이터베이승에 종속되지 않음
- 데이터베이스를 교체하는 상황에서도 비교적 적은 리스크를 부담함 

ORM의 단점 
1. ORM만으로 온전한 서비스를 구현하기에는 한계가 있음.
- 복잡한 서비스의 경우 직접 쿼리를 구현하지 않고 코드로 구현하기 어려움
- 복잡한 쿼리를 정확한 설계 없이 ORM만으로 구성하게 되면 속도 저하 등의 성능 문제가 발생할 수 있음. 
2. 애플리케이션의 객체 관점과 데이터베이스의 관계 관점의 불일치가 발생
- 세분성 :  ORM의 자동설계방법에 따라 데이터베이스에 있는 테이블 수와 애플리케이션의 엔티티 클래스의 수가 다른 경우가 발생함 
- 상속성 : RDBMS에는 상속이라는 개념이 없음
- 식별성 : RDBMSsms 기본키(PK)로 동일성을 정의함. 하지만 자바는 두 객체의 값이 같아도 다르다고 판단할 수 있음. 식별과 동일성의 문제
- 연관성 : 객체지향 언어는 객체를 참조함으로써 연관성을 나타내지만, RDBMS에서는 외래키(FK)를 삽입함으로써 연관성을 표현한다. 외래키 삽입하는 것은 양뱡향의 관계를 가지기 때문에 방향성이 없음
- 탐색 : 자바와 RDBMS는 어떤 값(객체)에 접근하는 방식이 다름. 자바에서는 특정 값에 접근하기 위해 객체 참조 같은 연결 수단을 활용한다. 이 방식은 객체를 연결하고 또 연결해서 접근하는 그래프 형태의 접근 방식이다. 
RDBMS에서는 쿼리를 최소화하고 조인을 통해 여러 테이블을 로드하고 값을 추출하는 접근 방식을 채택 

### 6.3 JPA
JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준으로 채택된 인터페이스의 모음이다. 내부적으로 JDBC 사용함. 
JPA 기반의 구현체는 하이버네이트, 이클립스 링크, 데이터뉴클리어스 대표적으로 이 세가지가 있으며, 하이버네이트가 가장 많이 사용된다. 

### 6.4 Hibernate 
하이버네이트는 자바의 ORM 프레임워크로 JPA가 정의하는 인터페이스를 구현하고 있는 JPA 구현체 중 하나이다. 

### 6.4.1 Spring Data JPA
Spring Data JPA는 JPA를 편리하게 사용할 수 있도록 지원하는 스프링 하위 프로젝트 중 하나이다. CRUD 처리에 필요한 인터페이스를 제공하며, 하이버네이트의 엔티티 매니저를 직접 다루지 않고 리포지터리를 정의해 사용함으로써 스프링이 적합한 쿼리를 동적으로 생성하는 방식으로 데이터베이스를 조작합니다. 이를 통해 하이버네이트에서 자주 사용되는 기능을 더 쉽게 사용할 수 있게 구현한 라이브러리임 

### 6.5 영속성 컨텍스트
영속성 컨텍스트(Persistence Context)는 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능을 수행한다. 엔티티 객체가 영속성 컨텍스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영하는 작업을 수행한다. 이처럼 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터는 해당 객체를 영속 객체라고 부른다. 영속성 컨텍스트는 세션 단위의 생명주기를 가진다. 데이터베이스에 접근하기 위한 세션이 생성되며 영속성 컨텍스트가 만들어지고, 세션이 종료되면 영속성 컨텍스트도 없어짐. 엔티티 매니저는 이러한 일련의 과정에서 영속성 컨텍스트에 접근하기 위한 수단으로 사용된다. 

### 6.5.1 엔티티 매니저
엔티티를 관리하는 객체이다. 엔티티 매니저는 데이터베이스에 접근해서 CRUD 작업을 수행한다. 엔티티 매니저는 엔티티 매니저 팩토리가 만들고, 엔티티 매니저 팩토리는 데이터베이스에 대응하는 객체로서 스프링 부트에서는 자동 설정 기능이 있기 때문에 application.propertise에서 작성한 최소한의 설정만으로도 동작하지만 JPA의 구현체 중 하나인 하이버네이트에서는 persistence.xml이라는 설정 파일을 구성하고 사용해야 하는 객체이다. 

### 6.7 엔티티 설계 
Spring Data JPA를 사용하면 데이터베이스에 테이블을 생성하기 위해 직접 쿼리를 작성할 필요가 없음. 이 기능을 가능하게 하는 것이 엔티티임. JPA에서 엔티티는 데이터베이스의 테이블에 대응하는 클래스임. 엔티티에는 데이터베이스에 쓰일 테이블과 칼럼을 정의하고, 엔티티에 애너테이션을 사용하면 테이블 간의 연관관계를 정의할 수 있음 

### 6.7.1 엔티티 관련 기본 애너테이션 
1. @Entity
해당 클래스가 엔티티임을 명시하기 위한 애너테이션, 클래스 자체는 테이블과 일대일로 매칭되며 해당 클래스의 인스턴스는 매핑되는 테이블에서 하나의 레코드를 의미함. 
2. @Table
엔티티 클래스는 테이블과 매핑되므로 특별한 경우가 아니면 @Table 애너테이션이 필요 없음. 클래스의 이름과 테이블의 이름을 다르게 지정해야 하는 경우에 사용된다. 
3. @Id
엔티티 클래스의 필드는 테이블의 칼럼과 매핑된다. @Id 애너테이션이 선언된 필드는 테이블의 기본값 역할로 사용된다. 모든 엔티티는 @Id 애너테이션이 필요함!!
4. @GeneratedValue
일반적으로 @Id 애너테이션과 함께 사용된다. 이 애너테이션은 해당 필드의 값을 어떤 방식으로 자동으로 생성할지 결정할 때 사용한다. 
값 생성방식은 

1) GeneratedValue 사용X(직접 할당)
애플리케이션에서 자체적으로 고유한 기본값을 생성할 경우 사용하는 방식, 내부에 정해진 규칙에 의해 기본값을 생성하고 식별자로 사용
2) AUTO
@GeneratedValue의 기본 설정값, 기본값을 사용하는 데이터베이스에 맞게 자동 생성함
3) IDENTITY
기본값 생성을 데이터베이스에 위임하는 방식, 데이터베이스의 AUTO_INCREMENT를 사용해 기본값을 생성한다.
4) SEQUENCE
@SequenceGenerator 애너테이션으로 식별자 생성기를 설정하고 이를 통해 값을 자동 주입받음. SequenceGenerator를 정의할 때는 name, sequenceName, allocationSize를 활용한다. 
@GeneratedValue에 생성기를 설정한다. 
5) TABLE
어떤 DBMS를 사용하더라도 동일하게 동작하기를 원할 경우 사용
식별자로 사요할 숫자의 보관 테이블을 별도로 생성해서 엔티티를 생성할 때마다 값을 갱신하며 사용한다.
@TableGenerator 애너테이션으로 테이블 정보를 설정 

5. @Column
엔티티 클래스의 필드는 자동으로 테이블 칼럼으로 매핑된다. 
6. @Transient
엔티티 클래스에는 선언되어 있는 필드지만, 데이터베이스에서는 필요없는 경우 이 애너테이션을 사용해 데이터베이스에서 이용하지 않게 할 수 있음. 

### 6.8 리포지터리 인터페이스 설계
Spring Data JPAsms JpaRepository를 기반으로 쉽게 데이터베이스를 사용할 수 있는 아키텍처를 제공하므로, 스프링 부트로 JpaRepository를 상속하는 인터페이스를 생성하면 기존의 다양한 메서드를 활용할 수 있음 

### 6.8.1 리포지터리 인터페이스 생성
리포지터리는 Spring Data JPA가 제공하는 이넡페이스임. 

### 6.9 DAO 설계 
DAO와 리포지터리는 역할이 비슷함. 실제로 리포지터리는 Spring Data JPA에서 제공하는 기능이기 때문에 기존의 스프링 프레임워크나 스프링 MVC 사용자는 리포지터리라는 개념을 사용하지 않고 DAO 객체로 데이터베이스에 접근했음. 

### 6.9.1 DAO 클래스 생성
DAO 클래스는 일반적으로 인터페이스-구현체 구성으로 생성한다. dao 패키지에는 ProductDAO 인터페이스, impl 패키지에는 ProductDAOImpl 클래스 생성한다. 

### 6.11 롬복의 주요 애너테이션 
@Getter, @Setter 

생성자 자동 생성 애너테이션 
@NoArgsConstructor : 매개변수가 없는 생성자를 자동 생성
@AllArgsConstructor : 모든 필드를 매개변수로 갖는 생성자를 자동 생성
@RequriedArgsConstructor: 필드 중 final이나 @NotNull이 설정된 변수를 매개변수로 갖는 생성자를 자동 생성 

@ToString 
toString() 메서드를 생성하는 애너테이션, 민감한 정보처럼 숨겨야 할 정보가 있다면 @ToString 애너테이션이 제공하는 exclude 속성을 사용해 특정 필드를 자동 생성에서 제외할 수 있음 

@EquelsAndHashCode 
객체의 동등성(Equality)와 동일성(Identity)을 비교하는 연산 메서드를 생성합니다. 

@Data
@Getter/@Setter, @RequiredArgsConstructor, @ToString, @EqualsAndHashCode를 모두 포괄하는 애너테이션 


### 7.3 테스트 코드를 작성하는 방법
### 7.3.1 Given-When-Then 패턴 
Given
테스트를 수행하기 전에 테스트에 필요한 환경을 설정하는 단계이다. 테스트에 필요한 변수를 정의하거나 Mock 객체를 통해 특정 상황에 대한 행동을 정의
When
테스트의 목적을 보여주는 단계, 실제 테스트 코드가 포함되며 테스트를 통한 결괏값을 가져오게 된다. 
Then
테스트의 결과를 검증하는 단계, 일반적으로 When 단계에서 나온 결괏값을 검증하는 작업을 수행한다. 결과값이 아니더라도 이 테스트를 통해 나온 결과에서 검증해야 하는 부분이 있다면 이 단계에 포함

Given-When-Then 패턴은 테스트 주도 개발에서 파생된 BDD(Behavior-Driven-Development)를 통해 탄생한 테스트 접근 방식입니다. 일반적으로 단위 테스트보다는 비교적 많은 환경을 포함해서 테스트하는 인수 테스트에서 사용하는 것에 적합하다고 알려져 있지만, 단위 테스트에서도 유용하게 활용 할 수 있으.ㅁ 

### 7.3.2 좋은 테스트를 작성하는 5가지 속성(F.I.R.S.T)
Fast, Isolated, Repeatable, Self-Validating, Timely

### 7.4 JUnit을 활용한 테스트 코드 작성 
JUnit은 자바 언어에서 사용되는 대표적인 테스트 프레임워크로서 단위 테스트를 위한 도구를 제공한다. 단위테스트 , 통합테스트 기능 제공 
JUnit은 크게 Jupiter, Platform, Vintage 이 세 모듈로 구성된다. 

### 7.5 JaCoCo를 활용한 테스트 커버리지 확인 
코드 커버리지는 소프트웨어의 테스트 수준이 충분한지를 표현하는 지표 중 하나임

### 7.6 테스트 주도 개발(TDD)
테스트 주도 개발은 반복 테스트를 이용한 소프트웨어 개발 방법론으로서 테스트 코드를 먼저 작성한 후 테스트를 통과하는 코드를 작성하는 과정을 반복하는 소프트웨어 개발 방식이다. 애자일 방법론 중 하나인 익스트림 프로그래밍의 Test-First 개념에 기반을 둔, 개발 주기가 짧은 개발 프로세스로 단순한 설계를 중시한다. 

3단계 개발 주기 
1. 실패 테스트 작성 : 실패하는 경우의 테스트 코드를 먼저 작성합니다.
2. 테스트를 통과하는 코드 작성 : 테스트 코드를 성공시키기 위한 실제 코드를 작성합니다. 
3. 리팩터링 : 중복 코드를 제거하거나 일반화하는 리팩터링을 수행한다. 

### 8.5 JPQL
@Query 애너테이션을 사용하면 직접 JPQL을 작성할 수 있음. 

### 8.6.1 QueryDSL
정적 타입을 이용해 SQL과 같은 쿼리를 생성할 수 있도록 지원하는 프레임워크

### 8.6.2 QueryDSL의 장점 
1. IDE가 제공하는 코드 자동 완성 기능을 사용할 수 있음
2. 문법적으로 잘못된 쿼리를 허용하지 않음. 따라서 정상적으로 활용된 Querydsl은 문법 오류를 발생시키지 않음
3. 고정된 SQL 쿼리를 작성하지 않기 때문에 동적으로 쿼리를 생성할 수 있음
4. 코드로 작성하므로 가독성 및 생산성이 향상됨
5. 도메인 타입과 프로퍼티를 안전하게 참고할 수 있음 

### 8.7 JPA Auditing 적용 
Spring Data JPA에서는 생성 주체, 생성 일자, 변경 주체, 변경 일자 이러한 값을 자동으로 넣어주는 기능을 제공한다. 
@EnableJpaAuditing 애너테이션 추가하면 됨. 

### 12.1 RestTemplate 
스프링에서 HTTP 통신 기능을 손쉽게 사용하도록 설계된 템플릿이다. 현재는 deprecate되어 잇따. 
-> WebClient로 대체 

### 12.3 WebClient란?
Spring WebFlux는 HTTP 요청을 수행하는 클라이언트로 WebClient를 제공한다. Webclient는 리엑터(Reactor) 기반으로 동작하는 API이다. 리액터 기반이므로 스레드와 동시성 문제를 벗어나 비동기 형식으로 사용할 수 있음 
WebClient의 특징으로는
논블로킹(Non-Blocking) I/O를 지원
리액티브 스트림의 백 프레셔를 지원
적은 하드웨어 리소스로 동시성을 지원
함수형 API를 지원
동기, 비동기 상호작용을 지원
스트리밍을 지원 

### 12.5 RestClient란? 
