```java
class MyObject implements Cloneable {
    public MyObject clone() {
        try {
            return (MyObject) super.clone();
        } catch (CloneNotSupportedException e) {
            // Cloneable을 구현했으므로 이 예외는 절대 발생하지 않는다
          throw new AssertionError(e);  
        }
    }
}
```

### 실수 1. 숫자 연산자 우선순위 오해 
- 이진 시프트(binary shift) <<, >> 가 등장하면 조금씩 문제가 발생한다. 
```java
public int hashCode() {
    return xmin + ymin << 8 + max << 16 + ymax << 24;
}
``` // 프로그래머가 의도한 연산 순서: xmin "+" ymin << 8 "+" xmax << 16 "+" ymax << 24 
    // 컴파일러가 이해한 연산 순서: xmin + ymin "<<" 8 + max "<<" 16 + ymax "<<" 24 

- 비트 연산자 (&, |)
```java 
int updateBits(int bits) {
    return bits & 0xFF00 + 1;
}
``` // 덧셈과 비트 중에 어느 것을 먼저 계산할까? 실제로 증감 연산자는 비트 연산자보다 우선순위가 높다. 따라서 작성자의 의도와 달리 표현식은 bits & 0xFF01로 계산된다. 항상 1로 설정하려 했던 최하위 비트는 결과적으로 bits에서 그대로 복사된다. 간단한 해결책은 바로 단일 표현식에서 비트 연산자와 산술 연산자를 함께 쓰지 않는 것이다. 특수한 연산자를 사용할 떄는 반드시 괄호를 추가하자! 

### 실수 2. 조건식의 괄호 누락
```java
if (!obj instanceof String) {} // 컴파일 에러: ! 연산자는 객체에 사용할 수 없음
if ((obj instanceof String)) {} // 올바른 코드 

if (flags == Flags.ACC_PUBLIC | Flags.ACC_FINAL) {} // 컴파일 에러: | 연산자는 불리언과 정수형에 사용할 수 없음
if (flags == (Flags.ACC_PUBLIC | Flags.ACC_FINAL)) {} // 올바른 코드 

- &&, ||의 우선순위 
if (index >= 0 && str.charAt(index) == ' ' ||
                  str.charAt(index) == '\t') {...} // 이 코드는 두 charAt() 메서드를 사용하기에 앞서 index 값이 음수가 되지 않도록 보호하려고 했는데, && 연산자의 우선순위가 더 높기 때문에 두번째 charAt()호출은 index >= 0로 보호할 수 없다. index에 음수가 들어가면 반드시 예외가 발생한다. 
if (index >= 0 && (str.charAt(index) == ' ' ||
                   str.charAt(index) == '\t')) {...} // 올바른 코드
                   // && 및 || 연산자가 단일 표현식에 등장할때마다 괄호로 묶자! 

- 삼항 연산자(조건 연산자 (?:))

return "Found " + multiple ? "multiple problems" : "a problem"; // 컴파일 에러: 타입 불일치, 불리언에 문자열 입력
return "Found " + (multiple ? "multiple problems" : "a problem"); // 올바른 코드 

static String indentString(String str, int indent) {
    int capacity = str.length() + indent < 0 ? 0 : indent; // 잘못된 우선 순위: 덧셈이 조건에 포함됨
    StringBuilder sb = new StringBuilder(capacity);
    for (int i = 0; i < indent; i++) {
        sb.append(' ');
    }
    sb.append(str);
    return sb.toString();
} // 원래의 의도는 indent가 음수이면, 아무 일도 하지 않고, 그렇지 않으면 str 앞에 indent 만큼 공백을 추가하는 것이다. 코드 작성자는 할당 최적화를 고려해 StringBuilder의 용량을 미리 정하려 했다. 하지만 괄호가 빠지는 바람에 계산이 틀리고 말아ㅣㅆ다. 해당 표현식은 str.length() + indent를 먼저 계산하고 이를 0과 비교하므로 capacity는 결국 0 또는 indent 값으로 설정된다. indent가 양수이거나 -str.length() 보다 작은 음수일 경우, capacity에 엉뚱한 값이 들어가긴 해도 메서드가 작동하긴 한다. 그러나 indent가 -str.length() 이상 -1 이하일 경우에는 메서드에서 NegativeArraySizeException 예외가 발생한다. StringBuilder는 결국 indent만큼 배열을 할당하려 하며, 이 값은 음수이기 때문이다. 

- 조건 연산자와 null 검사 
```java
String format(String value) {
    return "Value: " + value != null ? value : "(unknown)";
} // 원래 의도는 value가 null일 때 Value : (unknown)을 반환하고 그렇지 않으면 해당 문자열을 "Value: "과 결합하는 것이었다. 하지만 실제로 return 표현식은 다음과 같이 분석된다. (("Value: " + value) != null) ? value : "(unknown)"; 
// 결과적으로 문자열을 먼저 결합한 다음 null 검사를 수행하며, 그 결과는 결코 null이 될 수 없으므로 조건은 항상 참이 된다. 따라서 메서드는 무조건 접두사 없이 value만 반환하며 null일 경우에도 그대로 통과시킨다. 
```

```java 
// 엘라스틱서치 프로젝트도 유사한 문제가 발견된 적이 있다. ArrayList 객체 초기화 시 기본 용량을 지정하는 코드
List<String> trimAndAdd(List<String> input, String newItem) {
    List<String> result = new ArrayList<>(
        input.size() + newItem == null ? 0 : 1);
    for (String s : input) {
        result.add(s.trim());
    }
    if (newItem != null) {
        result.add(newItem.trim());
    }
    return result;
} // 반환할 List 원소 개수는 이미 정해져 있으므로 용량을 미리 할당할 수 있다면 그렇게 하는 것이 좋다. 그러나 괄호가 없는 한 덧셈 연산자는 수치 연산이 아닌 문자열 결합으로 먼저 해석된다. 결합 결과는 결고 null이 될 수 없으므로 ArrayList의 초기 용량은 항상 한 개의 원소만큼 할당된다. 
```

- 실수 방지 가이드 
1. 서로 다른 연산자가 포함된 복잡한 표현식은 다음과 같이 중간 변수를 이용해 분할한다. 
```java
String displayedValue = value != null ? value : "(unknown)";
return "Value: " + displayedValue;

// 마찬가지로 trimAndAdd() 예시의 ArrayList 초기화 코드는 다음과 같이 고칠 수 있다. 
int additionalElements = newItem == null ? 0 : 1;
List<String> result = new ArrayList<>(input.size() + additionalElements);
```

2. 문자열을 직접 결합하는 대신 다음과 같이 포메팅 메서드를 호출한다. 
```java
return String.format("Value: %s", value != null ? value : "(unknown)");
// 자바 15부터는 다음과 같은 방식으로 작성할 수 있다. 
return "Value: %s".formatted(value != null ? value : "(unknown)");
// 아쉽지만 현재 JVM 포맷팅 메서드는 문자열 연결보다 상당히 느리므로, 빈번하게 실행되는 코드 경로에는 쓸 수 없다. 그러나 결합 문자열을 UI에 표시할 때는 포맷팅 코드보다 UI 렌더링 코드가 전체적인 성능을 좌우할 가능성이 높다. 자바 9부터는 Objects.requireNonNullElse() API 메서드로 null 판단 조건 표현식을 대체할 수 있다. 의미를 명확히 할 수 있으며 연산자 우선순위 문제도 해결된다는 장점이 있다. 다음은 이 메서드를 정적으로 임포트해서 사용하는 예시이다. 
return "Value: " + requireNonNullElas(value, "(unknown)"); // 이 방식을 무조건 권장하는 것은 아님! 
// 일반적으로, ArrayList와 StringBuilder의 초기 용량 최적화 조치는 어그러지기 쉽다. 괄호를 잊지 않고 항상 올바르게 넣는다고 하더라더도 이후 로직이 변경되면(예: 리스트에 원소를 한 개 추가할때) 최적화된 초기용량이 바뀌곤 한다. 최초의 설정은 잊혀지기 쉽고, 용량 불일치 등의 문제는 추후 어떠한 테스트로도 밝혀내기 어렵다. 
```

### 실수 3. 덧셈이 아닌 결합으로 작동 
문자열 결합과 수치 가산에 공통적으로 이항 + 연산자를 사용한다는 점은 자바 구문의 문제거리 중 하나다. 숫자가 문자열에 결합되면 묵시적으로 문자열 변환 과정을 거치며 예상치 못한 버그가 발생할 위험이 있다. 
```java
String entryName = "Entry#" + index + 1; // 원래 0 부터 시작하는 인덱스값을 조정하려 했다. index = 4일 때 Entry#5라는 문자열을 생성하려고 했으나, 실제는 +는 두 번의 문자열 결합으로 해석되어 최종적으로 생성되는 문자열은 Entry#41이다. 
```
- 실수 방지 가이드 
1. 문자열 결합 중 산술 연산부는 항상 괄호로 감싼다. 
```java
String entryName = "Entry#" + (index + 1);
```// (price + tax) + "$" 처럼 괄호가 굳이 필요 없는 부분도 명시적으로 넣는다. 이렇게 하면 코드 가독성이 향상된다. 
2. 단일 표현식에서 산술 연산과 문자열 결합을 섞어서 쓰지 않는다. 산술 연산부는 다음과 같이 모두 중간 변수로 추출한다. 
```java
int adjustIndex = index + 1;
String entryName = "Entry#" + adjustIndex; 
```

3. 포매팅 메서드를 쓰면 코드가 견고해진다. (성능 저하는 감수해야 한다.)
```java
String entryName = String.format("Entry#%d", index + 1);
String entryName = MessageFormat.format("Entry#{0}", index + 1);
```

### 실수 4. 멀티라인 문자열 리터럴 
자바 15에 텍스트 블록 문법이 도입되기 전에 일반적으로 긴 문자열을 여러 줄에 걸쳐 결합하곤 했다. 

- 실수 방지 가이드 
1. 문자열 결합은 메서드 호출보다 우선순위가 낮다는 것을 명심한다. 배열 원소 접근, 타 메서드 호출, new 표현식이 아닌 한, 메서드 호출 한정자는 항상 괄호로 감싼다. 
2. 복합 한정자를 대상으로 메서드를 호출하지 않는다. 가급적이면 복합 한정자를 별도의 변수로 추출한다. 
3. 가능하면 자바 버전을 15이상으로 올리고 문자열 결합 대신 텍스트 블록을 사용한다. """ <내용> """

### 실수 5. 단항 덧셈 연산자 
자바에는 단항 + 연산자가 있다. 이 연산자는 대부분의 경우 완전히 무해하며 아무 일도 하지 않는다. 그러나 byte, char, short 타입에 붙이면 int 타입으로 확장 변환한다는 점을 유념해야 한다. 
```java
String error(String userName) {
    return "User not fount: " + 
          + '"' + userName + '"';
} // 두 번째 + 연산자가 나왔을때 컴파일러는 이를 "문자에 적용된 단항 연산자로 해석한다. 따라서 문자에 확장 변환이 일어나고 아스키 코드(34)로 변경된다. 이 메서드는 목표했던 User not found: "User" 대신 User not found: 34User"를 반환한다. 유닛 테스트로 UI 메시지의 정확성까지 판단하기 어렵다. 특히 에러 처리 코드에 따라 표시되는 메시지는 더욱 그런다. 
```

- 실수 방지 가이드 
1. 문자열 리터럴("")을 사용할 수 있는 곳에는 가능한 한 문자 리터럴('')을 사용하지 않는다. 이번 예시의 경우 문자 리터럴 '"' 대신 문자열 "\""을 쓰는 것이 좋다. 문자열 리터럴에 단항 덧셈 등의 산술 연산자를 쓰면 모두 컴파일 에러가 발생한다. 문자열 리터럴로 인해 성능이 저하된다 해도 대부분의 경우 미미한 수준에 그친다. 
2. 문자열 결합보다 String.format() 등의 포매팅 메서드를 먼저 고려한다. 
3. 정적 분석기가 경고한 부분은 함부로 자동 포매팅하지 않는다. 경고부터 바로 잡아야 한다. 자동 포매팅 기능은 문제를 그저 감춰 버릴 가능성이 매우 높다. 
4. 가능하면 단항 + 는 애초부터 쓰지 않도록 한다. 단항 + 연산자가 사용된 모든 곳을 보고하도록 정적 분석기를 설정한다. 이렇게 하면 자동 포매팅 기능도 정적 분석 경고에 방해가 되지 않을 것이다. +=, -= 이렇게 사용해야지 =+, =- 는 금지하자! 

### 실수 5. 조건 표현식의 묵시적 타입 변환

조건 표현식 또는 삼항 연산자는 if문과 매우 비슷하다. 
```java
return condition ? thenExpression : elseExpression;
// 다음 if문과 완전히 동일하다고 여겨진다. 

if (condition) {
    return thenExpression;
} else {
    return elseExpression;
}
``` // 대부분의 경우 타당하지만, 숫자를 다룰 때는 그렇지 않다. 

- 조건 표현식의 박싱된 숫자
문제는 조건 표현식의 then과 else가 매우 복잡하고 비직관적인 방식으로 타입을 변환한다는 사실이다. 박싱된 숫자를 다룰 때는 이러한 특성에 매우 주의해야한다. 
```java
Double valueOrZero(boolean condition, Double value) {
    return condition ? value : 0.0;
}
``` // 이 메서드는 condition이 참일때 임수를 변경하지 않고 그대로 반환하는 것처럼 보인다. 그러나 자바 언어 스펙에 따르면 조건 표현식의 최종 결과 타입을 결정하는 절차는 복잡하다. 자바에는 독립형 표현식과 다형성 표현식이 있다. 독립형 타입은 주변 콘텍스트와 무관하게 표현식 자체가 정의한다. 가령 표현식 a + b는 독립형 표현식이며 a와 b의 타입을 알면 항상 전체 표현식의 타입을 판단할 수 있다. 반면 Collections.emptyList()는 다형성 표현식이다. 이 표현식의 타입은 주변 콘텍스트에 따라 List<Integer>, List<String> 등의 다양한 List로 결정된다. 이를 테면 해당 표현식의 결과를 할당하는 변수의 타입 등이 주변 콘텍스트에 해당한다. 원시 타입 또는 원시 래퍼를 취급하는 조건 표현식은 무조건 독립형 표현식이므로 주변 콘텍스트는 결과 타입에 영향을 주지 않는다. 메서드 반환 타입이 Double이라는 사실은 표현식 타입과 아무런 관련이 없다. 타입을 결정하는 것은 condition ? value : 0.0이라는 표현식 자체다. then 표현식에 Integer나 Double 등의 박싱된 타입이 있고 else 표현식에는 int나 double 등의 원시 타입이 있으면 원시 타입이 우선시된다는 점이다. 따라서 valueOrZero()에서 조건 표현식의 결과 타입은 원시 double이다. 또한 valueOrZero()는 조건 표현식을 실행한 다음 결과를 다시 박싱한다. 메서드 반환 타입이 박싱된 Double이기 때문이다. 자바는 원시 타입을 박싱 타입으로 변환할 때 valueOf() 등의 정적 메서드를 묵시적으로 호출하며 언박싱 변환할 때는 doubleValue() 등의 인스턴스 메서드를 호출한다. 예제에서 벌어지는 모든 묵시적 연산을 명시적으로 작성하면 다음과 같이 작동한다. 

```java
Double valueOrZero(boolean condition, Double value) {
    return Double.valueOf(
            condition ? value.doubleValue() : 0.0);
}
``` // 이제 예시 코드의 문제는 상당히 명확해졌다. 첫째, value는 항상 박싱되며 그 외에도 두 개의 박싱된 값이 있으므로 불필요하게 메모리를 낭비할 위험이 있다. 더 중요한 둘째, valueOrZero(true, null)을 호출하면 어떻게 될까? 원래 코드만 보면 null을 반환할 것으로 예상하기 쉽다. 그러나 묵시적으로 value.doubleValue() 메서드가 호출되므로 NullPointerException이 발생한다. 

- 실수 방지 가이드 
1. 박싱된 원시 타입을 사용하지 않는다. 가끔 제네릭 타입을 다룰 때는 필요하지만 가능한 한 빨리 원시 값으로 변환하는 것이 좋다. 이렇게 하면 해당 변수가 null이 될 수 없음을 명확히 선언하는 효과도 생긴다. 
2. 박싱된 타입이 꼭 필요한 경우에는 조건 표현식이 아닌 if문을 쓴다. 코드는 더 장황해보일지 몰라도 혼란은 덜하다. 세부 내용을 완벽히 이해하고 작성된 조건 표현식이라 해도 코드의 불안정성은 여전히 남아 있다. 조건식에 쓰인 타입에 약간의 변화만 생겨도 결과는 에기치 못한 변화를 일으킬 수 있다. 
3. 숫자로 이루어진 조건 표현식은 독립형 표현식이므로 주변 콘텍스트가 타입에 영향을 미치지 않는다는 점을 유념한다. 

- 중첩 조건 표현식(nested conditional expression) 
중첩 조건 표현식에 박싱된 원시 타입을 쓰는 경우도 예상치 못한 결과가 발생할 수 있다. 
```java
static Integer mapValue(int input) {
    return input > 20 ? 2 :
           input > 10 ? 1 :
           null;
}
``` // 외관상은 문제가 없어 보인다. 이 메서드는 박싱된 Integer을 반환하므로 2, 1, null 등의 세 값은 모두 유효하다. 그러나 10 이하인 input 값으로 이 메서드를 호출하면 NullPointerException이 발생한다. 다음과 같이 조건 순서를 변경하면 제대로 작동한다.

```java
static Integer mapValue(int input) {
    return input <= 10 ? null :
           input <= 20 ? 1 :
           2;
}
``` // 원시 타입인 int가 null을 만나면 결과 타입은 Integer처럼 박싱된 타입이 된다.

```java
return Integer.valueOf(input > 20 ? 2 : 
    (input > 10 ? Integer.valueOf(1) : null).intValue());
``` // 두 개의 묵시적 자동 박싱 변환과 한 개의 자동 언박싱 변환이 있다.

```java
return input <= 10 ? null :
       Integer.valueOf(inpus <= 20 ? 1 : 2>);
``` // 한 개의 묵시정 자동 박싱 변환만 있다. 

- 실수 방지 가이드 
1. 중첩 조건 표현식을 지양하고 if문을 사용한다. 
2. 분기에 따라 다른 타입을 반환하는 조건 표현식은 쓰지 않는다. 하나 이상의 분기에 원시 타입이 있을 경우 특히 위험하다. 자동 타입 변환은 가끔 직관에 반하는 결과를 낸다. if문을 사용하는 편이 훨씬 더 안전하다. 

### 실수 7 비단락 논리 연산자 사용 

