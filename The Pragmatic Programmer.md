# 실용주의 프로그래머 리뷰/요약 (실무 예시: “상품 검색” 기준으로 구체화)

> 목적: 책의 핵심 원칙을 “운영 가능한 백엔드 습관”으로 바꾸기  
> 기준 도메인: **상품 검색 API** (트래픽/정렬/페이지네이션/폴백/테스트가 한 번에 들어가는 대표 케이스)

---

## 0. 들어가며

**한 줄 요약**  
이 책은 기술 스킬보다 **태도·판단·습관**을 바꿔서 결과물을 바꾸는 책이다.

**핵심 포인트**
- 완벽한 코드보다 **신뢰 가능한 전달**이 중요하다.
- 좋은 개발자는 문제를 숨기지 않고 **리스크를 드러내고 선택지를 만든다.**
- 품질은 미학이 아니라 운영 비용(장애/수정/속도/팀 스트레스)으로 돌아온다.

**현업 체크리스트**
- 이 기능이 실패하면 무엇이 망가지는가? (데이터/돈/보안/신뢰)
- 지금 못 고치는 품질 문제가 있다면 **확산 방지(판자 덮기)**를 했는가?
- 장애/버그 후에 **다음번엔 더 빨리 잡히게**(테스트/로그/지표) 만들었는가?

---

# 1. 실용주의 철학

## 1-1. 책임감: “고양이가 내 소스코드를 삼켰어요”

**한 줄 요약**  
책임감은 “내 탓/네 탓”이 아니라 **리스크를 조기에 공유하고 대안을 제시하는 능력**이다.

**핵심 포인트**
- 무지/실수를 숨기지 말고 빨리 드러내야 피해가 줄어든다.
- 통제 불가능한 리스크는 “책임 회피”가 아니라 **조기 공유 + 옵션 제시 + 합의**로 다룬다.
- 변명은 신뢰를 깎고, 대안은 신뢰를 쌓는다.

**현업 체크리스트**
- 통제할 수 없는 리스크가 뭐지? (외부 API, 인프라, 일정, 데이터 품질)
- 리스크가 있다면 **대응 옵션 2~3개**를 준비했나?
- 문제 보고 시 **사실/영향/조치/ETA/대안**을 한 번에 말할 수 있나?

**상품 검색 실무 예시**
- 상황: 검색엔진(Elasticsearch) 도입이 필요한데 인덱싱 파이프라인이 불안정함  
- 나쁜 대응: “아마 될 겁니다”, “엔진이 문제예요”  
- 좋은 대응(책 스타일):
  1) 리스크: 재색인 중 누락/지연 가능  
  2) 옵션 A: 배치 색인 + 최신 데이터는 DB 폴백  
  3) 옵션 B: 카테고리/필터는 DB, 키워드만 엔진(단계적 전환)  
  4) 합의: 1차는 옵션 B로 MVP, 지표 보고 2차 확대

**인용구**  
“어설픈 변명을 만들지 말고 대안을 제시하라.”

---

## 1-2. 소프트웨어 엔트로피: 깨진 창문

**한 줄 요약**  
작은 품질 문제를 방치하면 팀 전체가 “대충해도 된다”는 문화로 무너진다.

**핵심 포인트**
- 부패의 핵심은 기술이 아니라 **심리/문화**다.
- “나중에 고치자”는 대부분 안 온다.
- 못 고치면 최소한 **확산 방지(판자 덮기)**를 해야 한다.

**현업 체크리스트**
- 현재 코드에서 ‘깨진 창문 3개’를 말할 수 있나?
- 당장 못 고치면 **가드/로그/티켓**이라도 달았나?
- 품질 작업을 일정으로 인정하는 장치가 있나? (티켓화/게이트/정기 리팩터링)

**상품 검색 실무 예시**
- 깨진 창문들:
  - `sort` 파라미터가 화이트리스트 없이 그대로 SQL에 반영됨
  - `size=10000` 같은 요청이 가능(제한 없음)
  - 정렬이 불안정해서 페이지 중복/누락이 발생하는데 테스트가 없음
- 판자 덮기(즉시 조치):
  - sort 허용 목록만, size 최대 100 제한
  - `ORDER BY created_at DESC, id DESC` (tie-breaker)
  - “중복/누락 방지” 회귀 테스트 1개 추가
  - 느린 쿼리 로그 + p95 메트릭 추가

**인용구**  
“깨진 창문을 내버려두지 말라.”

---

## 1-3. 돌멩이 수프: 변화의 촉매

**한 줄 요약**  
큰 설득보다 **작동하는 작은 결과물**이 조직을 움직인다.

**핵심 포인트**
- 조직은 큰 변화에 방어적이다.
- 작은 가치 제공 → 체감 → 자연스러운 확장.
- 데모는 가장 강한 설득 도구다.

**현업 체크리스트**
- 기능을 “가장 작은 데모 단위”로 자를 수 있나?
- 1주 안에 보여줄 수 있는 최소 가치가 뭔가?
- 1차 결과물이 독립적으로 의미 있나?

**상품 검색 실무 예시**
- “검색 고도화” 단계적 접근:
  1) 카테고리 + 최신순(기본 검색)
  2) 브랜드/가격 필터
  3) 키워드 검색(초기엔 DB LIKE)
  4) 트래픽/정확도 근거가 쌓이면 검색엔진 도입

**인용구**  
“변화의 촉매가 되라.”

---

## 1-4. 적당히 괜찮은 소프트웨어

**한 줄 요약**  
“완벽”이 아니라 **합의된 품질 기준**으로 빠르게 전달하고 피드백으로 개선한다.

**핵심 포인트**
- 완벽은 불가능하고, 늦은 완벽은 가치가 떨어진다.
- “적당히 괜찮음” 기준은 사용자/비즈니스와 합의해야 한다.
- 품질 기준은 기능보다 먼저 합의하는 게 안전하다.

**현업 체크리스트**
- 절대 타협 불가 기준은? (정확도/속도/보안/무결성)
- p95 응답시간/에러율 같은 목표가 있나?
- 장애 시 폴백 정책이 합의됐나?

**상품 검색 실무 예시(품질 합의)**
- p95 300ms 목표, p99 800ms까지 허용
- 정렬 안정성(중복/누락 없음) 절대 보장
- 검색엔진 장애 시 DB 폴백(랭킹 품질 저하는 허용)

**인용구**  
“오늘의 훌륭한 소프트웨어는 내일의 완벽한 소프트웨어보다 낫다.”

---

## 1-5. 지식 포트폴리오

**한 줄 요약**  
개발자의 가치는 지식 자체가 아니라 **지식을 갱신하는 습관**에서 나온다.

**핵심 포인트**
- 기술은 낡는다 → 포트폴리오처럼 관리해야 한다.
- 다각화 + 리스크 관리 + 정기 재조정.
- 모르면 인정하고 찾고 공유하는 문화가 성장 속도를 만든다.

**현업 체크리스트**
- 업무 핵심 1개 + 기초 1개를 동시에 챙기나?
- 배운 걸 문서/블로그로 남겨 재사용하나?
- 새로운 기술은 프로토타입으로 리스크를 싸게 검증하나?

**상품 검색 실무 예시**
- 검색엔진 학습 로드맵:
  - 기초: 역색인/분산/랭킹
  - 실무: 색인 정합성(지연/누락), 재색인, 장애 폴백
  - 산출물: “검색 장애 대응 체크리스트”, “정렬 안정성 가이드”

**인용구**  
“지식에 대한 투자가 언제나 최고의 이윤을 낸다.”

---

## 1-6. 소통하라

**한 줄 요약**  
개발자의 영향력은 코드가 아니라 **소통**에서 완성된다.

**핵심 포인트**
- 청중을 알아야 전달이 된다.
- “응답”은 신뢰의 기본이다.
- 문서는 내용뿐 아니라 가독성이 품질이다.

**현업 체크리스트**
- 문제 보고 시 **사실/영향/조치/다음 업데이트 시간**을 포함하나?
- 상대가 원하는 깊이를 맞추나? (임원/PM/개발자)
- 용어사전(Glossary)을 유지하나?

**상품 검색 실무 예시(장애 공지 템플릿)**
- 사실: 12/25 18:30부터 검색 p95 250ms → 1.8s  
- 영향: 검색 지연, 일부 타임아웃  
- 조치: 인덱스 상태 확인, 19:10까지 롤백/재색인 진행  
- 대안: 인기정렬 임시 비활성화, 최신순 폴백  
- 다음 업데이트: 19:00, 19:10

**인용구**  
“응답하라.”

---

# 2. 실용주의 접근법

## 2-1. 중복의 해악: DRY

**한 줄 요약**  
DRY는 코드 줄 수가 아니라 **지식(규칙)의 중복**을 없애는 원칙이다.

**핵심 포인트**
- 같은 규칙이 여러 곳에 있으면 반드시 불일치가 생긴다.
- 주석은 저수준 구현이 아니라 고수준 의도/결정 이유를 남겨야 한다.
- 문서/코드 불일치도 DRY 위반이다.

**현업 체크리스트**
- 비즈니스 규칙이 컨트롤러/서비스/DB/배치에 중복되어 있지 않나?
- 검증 로직이 프론트와 백엔드에서 서로 다르지 않나?
- “한 곳만 고치면 된다”는 상태인가?

**상품 검색 실무 예시**
- 정렬 정책이 흩어지면 사고가 난다:
  - Controller에서 sort 파싱
  - Service에서 sort 변환
  - Query에서 sort 적용
- 해결: `SortPolicy`(허용 목록/기본값/매핑)를 단일 컴포넌트로 두고  
  모든 요청을 `SearchCondition`으로 **한 번만 정규화**한다.

**인용구**  
“모든 지식은 시스템 내에서 단일하고 애매하지 않은 표현을 가져야 한다.”

---

## 2-2. 직교성(Orthogonality)

**한 줄 요약**  
직교성은 **변경 전파를 막는 경계 설계**다.

**핵심 포인트**
- 한 변경이 여러 모듈을 흔들면 결합도가 높은 것.
- 직교적 설계는 생산성과 리스크를 동시에 줄인다.
- 테스트가 어려우면 대체로 결합이 과하다.

**현업 체크리스트**
- “정렬 방식 변경”이 몇 개 모듈에 영향을 주나?
- DB 스키마 변경이 연쇄 폭발하나?
- 외부 연동은 경계(어댑터/ACL)로 격리했나?

**상품 검색 실무 예시**
- 포트/어댑터 분리:
  - `ProductSearchPort`
  - `DbSearchAdapter` / `EsSearchAdapter`
  - 라우팅은 feature flag
- 검색엔진 교체가 서비스 전체 변경이 아니라 어댑터 교체로 끝난다.

**인용구**  
“하나가 바뀌어도 나머지에 영향이 없게 하라.”

---

## 2-3. 가역성(Reversibility)

**한 줄 요약**  
되돌릴 수 있게 만들면 초기 결정의 공포가 줄고 변화에 강해진다.

**핵심 포인트**
- “이 방법밖에 없어”는 거의 항상 착각이다.
- 최종 결정은 없다 → 롤백/전환 경로를 남겨야 한다.
- 기술/벤더/배포 구조도 유연해야 한다.

**현업 체크리스트**
- 새로운 기술 도입 시 “원복 버튼”이 있나?
- 배포/설정 변경이 되돌릴 수 있나?
- 데이터 마이그레이션 롤백 플랜이 있나?

**상품 검색 실무 예시**
- offset 페이지네이션 → cursor 페이지네이션 전환
  - API 버전/파라미터로 병행 지원
  - 점진적 전환 + 지표 확인 후 디프리케이트

**인용구**  
“최종 결정이란 없다.”

---

## 2-4. 예광탄(Tracer Bullets) vs 프로토타입

**한 줄 요약**  
예광탄은 **계속 쓸 제품 골격**, 프로토타입은 **학습하고 버릴 실험**이다.

**핵심 포인트**
- 예광탄: 운영 가능한 최소 골격(로그/에러/지표 포함)
- 프로토타입: 위험 검증 중심(버려도 됨)
- 둘을 혼동하면 대충 만든 코드가 운영에 들어간다.

**현업 체크리스트**
- 지금 만드는 게 예광탄인지 프로토타입인지 합의했나?
- 프로토타입은 “버릴 코드”임을 명확히 했나?
- 예광탄에는 최소 관측/에러 처리가 포함됐나?

**상품 검색 실무 예시**
- 프로토타입 질문: “ES 도입 시 p95가 실제로 줄까?”
  - 샘플 인덱싱 + 성능 측정
- 예광탄 1차 API:
  - `GET /products/search?categoryId=&sort=&page=&size=`
  - 표준 에러 포맷 + 기본 지표(p95, error rate)
  - 엔진 장애 시 DB 폴백

**인용구**  
“프로토타입을 통해 학습하라.”

---

## 2-5. 추정(Estimation)

**한 줄 요약**  
추정은 맞추는 기술이 아니라 **놀람을 줄이는 커뮤니케이션 기술**이다.

**핵심 포인트**
- 단위 선택이 기대치를 바꾼다(130일 vs 6달).
- 기록하고 비교해야 추정 실력이 는다.
- 프로젝트 일정은 반복을 통해 정제된다.

**현업 체크리스트**
- 불확실성을 숫자로 숨기지 말고 범위로 표현했나?
- 추정 근거(가정/리스크)를 함께 적었나?
- 종료 후 실제와 비교하고 원인을 학습했나?

**상품 검색 실무 예시**
- “검색엔진 도입 2주”는 위험하다(정합성/재색인/폴백/관측 포함).
- 그래서 1차 목표를 “키워드만 엔진” 같은 단계로 쪼개고  
  **1~2달(리스크 포함)** 같은 범위로 말하는 게 안전하다.

**인용구**  
“추정을 통해 놀람을 피하라.”

---

# 3. 기본 도구: 디버깅

**한 줄 요약**  
디버깅은 ‘감’이 아니라 **재현과 증명의 루틴**이다.

**핵심 포인트**
- 비난은 시간을 태우고 품질은 안 오른다.
- 재현이 안 되면 고친 것도 아니다.
- 놀라운 실패는 “내 가정이 틀렸다”는 신호다.
- 버그가 빠져나가면 테스트 그물을 조여야 한다.

**현업 체크리스트**
- 재현 케이스(입력/환경/데이터)를 확보했나?
- 원인을 증명했나? (로그/지표/덤프)
- 재발 방지(테스트/가드/모니터링)를 추가했나?

**상품 검색 실무 예시(중복/누락 버그)**
- 증상: page=2부터 중복 상품 노출
- 원인: `created_at`만 정렬 → 동률에서 순서 흔들림
- 해결:
  - `ORDER BY created_at DESC, id DESC` (tie-breaker)
  - 회귀 테스트: 동일 조건 1~3페이지 조회 시 중복/누락 없음 검증
  - 지표: 검색 페이지별 결과 수/중복률 로그 샘플링

**인용구**  
“비난 대신 문제를 해결하라.”

---

# 4. 실용주의 편집증: 방어적으로 설계하기

## 4-1. Fail Fast: 죽은 프로그램은 거짓말을 하지 않는다

**한 줄 요약**  
불가능한 상태를 감지하면 “계속 진행”이 아니라 **안전한 방식(중단/격리/폴백)**으로 전환하라.

**핵심 포인트**
- 조기 감지는 피해를 줄인다.
- 실무는 “즉시 종료”만 답이 아니다:
  - 돈/무결성/보안: 중단이 맞음
  - 검색/조회: 격리/폴백이 맞음

**현업 체크리스트**
- 이 기능은 실패하면 “중단”해야 하나 “폴백”해야 하나?
- 타임아웃/서킷브레이커/재시도 정책이 있나?
- 장애 시 사용자 메시지/대체 경로가 합의됐나?

**상품 검색 실무 예시(폴백)**
- ES 장애 시:
  - 키워드 검색은 “일시 불가” + 카테고리/인기/최신은 DB 유지
  - 또는 전체를 DB LIKE로 폴백(성능 저하 감수)

**인용구**  
“죽은 프로그램은 거짓말을 하지 않는다.”

---

## 4-2. 단정적 프로그래밍(Guards)

**한 줄 요약**  
“절대 일어나지 않는다”는 생각이 들면 **검사 코드를 추가**하라.

**핵심 포인트**
- 입력 검증은 신뢰도를 만든다.
- 시스템 경계(API)에서 가드가 있어야 내부가 단순해진다.
- 자원/상태 전이는 특히 단정을 세워야 한다.

**현업 체크리스트**
- size 상한, sort 화이트리스트, 필터 조합 유효성 검증이 있나?
- 에러 응답 포맷이 일관적인가?
- 요청 파라미터 + traceId가 로그에 남는가?

**상품 검색 실무 예시(검증 규칙)**
- `size`는 1~100
- `sort`는 LATEST/PRICE_ASC/PRICE_DESC/POPULAR만 허용
- `priceMin <= priceMax`
- 없는 카테고리는 404 또는 빈 결과(정책 합의)

**인용구**  
“하지만 물론 그건 절대 일어나지 않을 거야.”

---

## 4-3. 예외는 정상 흐름이 아니다

**한 줄 요약**  
예외는 도메인 흐름이 아니라 **비정상/실패 신호**로 써야 한다.

**핵심 포인트**
- 입력 검증 실패(400) vs 시스템 장애(500) vs 일시 오류(503) 구분이 중요하다.
- 재시도 가능 여부를 클라이언트가 알 수 있어야 한다.

**현업 체크리스트**
- 400/401/403/404/409/500/503를 상황에 맞게 구분했나?
- errorCode/message/traceId가 있는가?
- 재시도 가능한 오류를 분리했나?

**상품 검색 실무 예시**
- `sort=HACK`: 400 + `INVALID_SORT`
- ES 타임아웃:
  - 폴백 성공: 200(폴백 결과) + `X-Fallback: true`
  - 폴백 실패: 503 + “잠시 후 재시도” 안내

**인용구**  
“예외는 정상 흐름이 아니다.”

---

# 5. 유연함: 결합도 줄이기 / 디미터 / 설정(메타데이터)

## 5-1. 결합도 줄이기 + 디미터 법칙

**한 줄 요약**  
객체를 타고타고 들어가는 코드는 변경에 약하고 테스트도 어렵다.

**핵심 포인트**
- 결합이 늘면 무관한 변화가 내 코드에 영향을 준다.
- 디미터 법칙은 결합도를 낮추는 실용적 가드레일이다.
- 성능 때문에 결합을 선택하면 의식적으로 선택하고 문서화해야 한다.

**현업 체크리스트**
- Controller가 도메인 내부 구조를 과하게 아나?
- 검색 조건 변환/검증이 한 곳에 모여 있나?
- 외부 연동은 어댑터로 격리했나?

**상품 검색 실무 예시**
- `SearchRequest -> SearchCondition` 변환을 Assembler로 단일화
- 서비스는 SearchCondition만 받기
- 쿼리 레이어는 조건 객체만 보고 SQL/DSL 구성

**인용구**  
“모듈간의 결합도를 최소화하라.”

---

## 5-2. 통합하지 말고 설정하라(Feature Flag / 메타데이터)

**한 줄 요약**  
바뀔 수 있는 정책은 코드에 박지 말고 **설정/플래그로 빼라.**

**핵심 포인트**
- 정책은 자주 바뀐다(기본 정렬, 필터 노출, 제한치).
- feature flag는 가역성을 높이고 장애 대응 속도를 높인다.

**현업 체크리스트**
- 검색엔진 라우팅 on/off 플래그가 있나?
- size 제한, 필터 제한이 설정으로 관리되나?
- 운영자가 즉시 조절할 수 있나?

**상품 검색 실무 예시(플래그)**
- `SEARCH_ENGINE_ENABLED`
- `POPULAR_SORT_ENABLED`
- `DB_FALLBACK_ENABLED`

**인용구**  
“통합하지 말고 설정하라.”

---

# 6. 코딩하는 동안: 의도/리팩터링/테스트

## 6-1. 우연에 맡기는 프로그래밍 금지

**한 줄 요약**  
왜 돌아가는지 모르는 코드는 언젠가 반드시 터진다.

**현업 체크리스트**
- 왜 이 쿼리가 빠른지/느린지 설명 가능한가?
- 데이터 크기/트래픽 가정을 문서화했나?
- 경계 조건(빈 키워드, 극단 필터)을 테스트했나?

**상품 검색 실무 예시**
- “LIKE %keyword%도 괜찮겠지”는 우연에 맡기는 설계다.  
- 의도적 설계: 키워드 길이 제한 + 전환 계획(검색엔진/인덱스) + 성능 지표

---

## 6-2. 리팩터링

**한 줄 요약**  
리팩터링은 나중이 아니라 “지금”이 가장 싸다.

**현업 체크리스트**
- 리팩터링과 기능 추가를 동시에 하지 않나?
- 리팩터링 전 테스트가 있나?
- 리팩터링 후보를 티켓화했나?

**상품 검색 실무 예시(절차)**
1) 현재 동작을 고정하는 테스트(API/통합) 추가  
2) `SearchCondition` 중심으로 QueryBuilder 분리  
3) 정렬/필터를 전략으로 분리  
4) 마지막에 프로파일링으로 병목 확인

**인용구**  
“일찍 리팩터링하고, 자주 리팩터링하라.”

---

## 6-3. 테스트 / 회귀 테스트(Regression Test)

**한 줄 요약**  
테스트가 없으면 사용자가 테스트한다.

**현업 체크리스트**
- 검색 결과 중복/누락 방지 테스트가 있나?
- 파라미터 검증(400) 테스트가 있나?
- 정렬 안정성(tie-breaker) 테스트가 있나?
- p95/에러율 지표가 있나?

**상품 검색 실무 예시(회귀 테스트 1개)**
- 같은 조건으로 1~3페이지 조회 시:
  - 중복 없음
  - 누락 없음
  - 정렬 유지

**인용구**  
“소프트웨어를 테스트하라. 그렇지 않으면 사용자가 테스트하게 될 것이다.”

---

# 7. 프로젝트 전에: 요구사항 채굴/추적/용어사전

**한 줄 요약**  
요구사항은 “수집”이 아니라 **채굴**이고, 범위 증가는 반드시 **추적**해야 한다.

**핵심 포인트**
- 사용자 말 그대로가 아니라 “왜”를 찾아야 한다.
- 요구사항이 너무 구체적이면 정책 변화에 약해진다.
- “기능 하나만 더”를 기록하지 않으면 일정이 무너져도 이유를 설명 못 한다.
- 용어사전이 없으면 팀이 서로 다른 말을 한다.

**현업 체크리스트**
- “정확도”의 의미 합의(랭킹? 재고 반영? 최신성?)
- 상품/옵션/재고/가격/노출 여부 용어 정의
- 변경 요청: 누가/언제/왜/영향(일정) 기록

**상품 검색 요구사항 5줄 템플릿**
- 무엇을: 사용자는 키워드/카테고리로 상품을 검색할 수 있다.  
- 누가: 로그인/비로그인 모두 가능.  
- 언제: p95 300ms 이내 응답.  
- 성공 조건: 정렬/필터 적용, 페이지 중복/누락 없음.  
- 실패 조건: 엔진 장애 시 폴백 또는 명확한 안내(503).

**인용구**  
“요구사항을 수집하지 말고 채굴하라.”

---

# 8. 팀/자동화/가차 없는 테스트(운영 체계)

**한 줄 요약**  
품질을 “개인의 열정”이 아니라 **시스템(자동화/테스트/관측)**으로 만든 팀이 결국 이긴다.

**현업 체크리스트**
- CI에서 테스트/린트/정적 분석이 기본으로 돌아가나?
- 배포 자동화 + 롤백이 쉬운가?
- 장애 대응 체크리스트/런북이 있는가?

**상품 검색 실무 예시**
- 배포 후 p95/에러율 자동 모니터링
- 이상치면 알람 + 플래그로 폴백
- 장애 후 포스트모템 + 테스트 그물 조이기

**인용구**  
“일찍 테스트하고, 자주 테스트하라. 자동으로 테스트하라.”

---

# 9. 추가로 공부하면 좋은 주제(책 내용과 직결)

1) 장애 대응(Incident) 루틴  
- 재현/원인/재발방지(포스트모템), 롤백 전략, feature flag 운영, 런북

2) 관측 가능성(Observability)  
- 구조화 로그, 메트릭(p95/p99), 트레이싱, SLI/SLO

3) 안전장치 패턴  
- 타임아웃, 재시도(백오프), 서킷 브레이커, 벌크헤드

4) 검색 도메인 필수 기초  
- 정렬 안정성(tie-breaker), 페이지네이션(offset/cursor)  
- 색인 정합성(지연/누락)과 재색인 전략  
- 폴백 설계(성능/정확도 트레이드오프)

---

# 10. 한 문장 결론

실용주의 프로그래머는 “완벽한 코드”가 아니라 “신뢰 가능한 결과”를 만들기 위해 **책임·품질·소통·자동화**를 습관으로 만든다.
